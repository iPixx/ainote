<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Scenario Testing - aiNote</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            padding: 20px;
            background: #f5f5f5;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid #dc3545;
            background: #f8f9fa;
            border-radius: 0 4px 4px 0;
        }
        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .scenario-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
        }
        .scenario-title {
            font-weight: bold;
            color: #dc3545;
            margin-bottom: 10px;
        }
        .scenario-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .status-ready { background: #e9ecef; color: #495057; }
        .status-testing { background: #fff3cd; color: #856404; }
        .status-pass { background: #d4edda; color: #155724; }
        .status-fail { background: #f8d7da; color: #721c24; }
        .error-details {
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            border-left: 3px solid #dc3545;
        }
        button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        button:hover { background: #c82333; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .btn-success { background: #28a745; }
        .btn-success:hover { background: #218838; }
        .log {
            background: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .stats-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #e9ecef;
            padding: 10px 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 11px;
            color: #6c757d;
            text-transform: uppercase;
        }
        .recovery-section {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .recovery-title {
            color: #0c5460;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí• Error Scenario Testing</h1>
        <p>Comprehensive error handling validation for all failure modes and edge cases</p>
        
        <div class="test-section">
            <h3>üéÆ Test Controls</h3>
            <button onclick="runAllErrorScenarios()" class="btn-success">üöÄ Run All Error Tests</button>
            <button onclick="runFileSystemErrors()">üìÅ File System Errors</button>
            <button onclick="runPermissionErrors()">üîí Permission Errors</button>
            <button onclick="runCorruptionErrors()">üíø Corruption Errors</button>
            <button onclick="runNetworkErrors()">üåê Network Errors</button>
            <button onclick="runResourceErrors()">üíæ Resource Errors</button>
            <button onclick="clearResults()">üßπ Clear Results</button>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="totalTests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="passedTests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="failedTests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="errorRate">0%</div>
                <div class="stat-label">Error Rate</div>
            </div>
        </div>

        <div class="test-section">
            <h3>üéØ Error Scenarios</h3>
            <div class="scenario-grid" id="scenarioGrid"></div>
        </div>

        <div class="recovery-section">
            <div class="recovery-title">üîÑ Error Recovery Strategies</div>
            <div id="recoveryStrategies"></div>
        </div>

        <div class="test-section">
            <h3>üìù Error Log</h3>
            <div id="errorLog" class="log"></div>
        </div>
    </div>

    <!-- Enhanced Error Simulation Tauri Mock -->
    <script>
        const errorScenarios = {
            fileSystem: [
                { name: 'File Not Found', trigger: 'nonexistent_file', error: 'File not found' },
                { name: 'Directory Not Found', trigger: 'nonexistent_dir', error: 'Directory not found' },
                { name: 'File Already Exists', trigger: 'duplicate_file', error: 'File already exists' },
                { name: 'Invalid Path', trigger: 'invalid_path', error: 'Invalid file path' },
                { name: 'Path Too Long', trigger: 'long_path', error: 'Path name too long' },
                { name: 'Reserved Filename', trigger: 'reserved_name', error: 'Reserved filename' }
            ],
            permissions: [
                { name: 'Read Permission Denied', trigger: 'no_read_perm', error: 'Permission denied reading file' },
                { name: 'Write Permission Denied', trigger: 'no_write_perm', error: 'Permission denied writing file' },
                { name: 'Execute Permission Denied', trigger: 'no_exec_perm', error: 'Permission denied accessing directory' },
                { name: 'Admin Rights Required', trigger: 'need_admin', error: 'Administrator privileges required' },
                { name: 'File Locked by Process', trigger: 'file_locked', error: 'File is locked by another process' },
                { name: 'Directory Access Denied', trigger: 'dir_access_denied', error: 'Access denied to directory' }
            ],
            corruption: [
                { name: 'Corrupted File Content', trigger: 'corrupt_content', error: 'File content is corrupted' },
                { name: 'Invalid File Format', trigger: 'invalid_format', error: 'Invalid file format' },
                { name: 'Truncated File', trigger: 'truncated_file', error: 'File appears to be truncated' },
                { name: 'Encoding Issues', trigger: 'encoding_error', error: 'File encoding error' },
                { name: 'Metadata Corruption', trigger: 'corrupt_metadata', error: 'File metadata corrupted' },
                { name: 'Filesystem Corruption', trigger: 'fs_corrupt', error: 'Filesystem corruption detected' }
            ],
            network: [
                { name: 'Network Timeout', trigger: 'network_timeout', error: 'Network operation timed out' },
                { name: 'Connection Lost', trigger: 'connection_lost', error: 'Network connection lost' },
                { name: 'DNS Resolution Failed', trigger: 'dns_fail', error: 'DNS resolution failed' },
                { name: 'Remote Server Error', trigger: 'server_error', error: 'Remote server error' },
                { name: 'SSL Certificate Error', trigger: 'ssl_error', error: 'SSL certificate validation failed' },
                { name: 'Bandwidth Limit', trigger: 'bandwidth_limit', error: 'Bandwidth limit exceeded' }
            ],
            resources: [
                { name: 'Out of Memory', trigger: 'out_of_memory', error: 'Insufficient memory' },
                { name: 'Disk Full', trigger: 'disk_full', error: 'Disk space exhausted' },
                { name: 'Too Many Open Files', trigger: 'too_many_files', error: 'Too many open files' },
                { name: 'CPU Limit Exceeded', trigger: 'cpu_limit', error: 'CPU usage limit exceeded' },
                { name: 'Process Limit', trigger: 'process_limit', error: 'Process limit reached' },
                { name: 'File Size Limit', trigger: 'size_limit', error: 'File size limit exceeded' }
            ]
        };

        const errorResults = new Map();
        let testResults = [];

        window.__TAURI__ = {
            core: {
                invoke: async (command, args) => {
                    // Check for error triggers in arguments
                    const argsStr = JSON.stringify(args || {});
                    
                    // Simulate different types of errors based on triggers
                    for (const [category, scenarios] of Object.entries(errorScenarios)) {
                        for (const scenario of scenarios) {
                            if (argsStr.includes(scenario.trigger)) {
                                const error = new Error(scenario.error);
                                error.code = scenario.trigger.toUpperCase();
                                throw error;
                            }
                        }
                    }
                    
                    // Normal mock responses for non-error cases
                    switch (command) {
                        case 'validate_vault':
                            return !argsStr.includes('invalid');
                        case 'load_vault':
                            return argsStr.includes('empty') ? [] : [
                                { name: 'test.md', is_dir: false, size: 1024 }
                            ];
                        case 'write_file':
                        case 'auto_save_file':
                            return null;
                        default:
                            return null;
                    }
                }
            }
        };
    </script>

    <script type="module">
        import AppState from './src/js/state.js';
        import VaultManager from './src/js/services/vault-manager.js';
        import AutoSave from './src/js/services/auto-save.js';

        function log(message, type = 'info') {
            const logDiv = document.getElementById('errorLog');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#00ff00';
            logDiv.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}</span>\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStats() {
            const total = testResults.length;
            const passed = testResults.filter(r => r.passed).length;
            const failed = total - passed;
            const errorRate = total > 0 ? ((failed / total) * 100).toFixed(1) : 0;

            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = failed;
            document.getElementById('errorRate').textContent = errorRate + '%';
        }

        function createScenarioCard(scenario, category) {
            const card = document.createElement('div');
            card.className = 'scenario-card';
            card.innerHTML = `
                <div class="scenario-title">${scenario.name}</div>
                <div class="scenario-status status-ready" id="status-${scenario.trigger}">Ready</div>
                <div>Expected: ${scenario.error}</div>
                <button onclick="testScenario('${scenario.trigger}', '${category}')">Test Scenario</button>
                <div class="error-details" id="details-${scenario.trigger}" style="display: none;"></div>
            `;
            return card;
        }

        function renderScenarios() {
            const grid = document.getElementById('scenarioGrid');
            grid.innerHTML = '';

            Object.entries(errorScenarios).forEach(([category, scenarios]) => {
                const categoryTitle = document.createElement('div');
                categoryTitle.innerHTML = `<h4>${category.charAt(0).toUpperCase() + category.slice(1)} Errors</h4>`;
                categoryTitle.style.gridColumn = '1 / -1';
                grid.appendChild(categoryTitle);

                scenarios.forEach(scenario => {
                    grid.appendChild(createScenarioCard(scenario, category));
                });
            });
        }

        async function testScenario(trigger, category) {
            const statusElement = document.getElementById(`status-${trigger}`);
            const detailsElement = document.getElementById(`details-${trigger}`);
            
            statusElement.textContent = 'Testing...';
            statusElement.className = 'scenario-status status-testing';
            
            log(`Testing scenario: ${trigger}`, 'info');

            try {
                const appState = new AppState();
                const vaultManager = new VaultManager(appState);
                const autoSave = new AutoSave(appState);

                let testPassed = false;
                let errorMessage = '';

                // Test different operations based on category
                switch (category) {
                    case 'fileSystem':
                        try {
                            await vaultManager.validateVault(`/test/${trigger}/path`);
                            errorMessage = 'Expected error but operation succeeded';
                        } catch (error) {
                            testPassed = true;
                            errorMessage = `Correctly caught: ${error.message}`;
                        }
                        break;

                    case 'permissions':
                        try {
                            await vaultManager.loadVault(`/test/${trigger}/vault`);
                            errorMessage = 'Expected permission error but operation succeeded';
                        } catch (error) {
                            testPassed = true;
                            errorMessage = `Correctly caught: ${error.message}`;
                        }
                        break;

                    case 'corruption':
                        try {
                            const files = await vaultManager.loadVault(`/test/${trigger}/vault`);
                            errorMessage = 'Expected corruption error but operation succeeded';
                        } catch (error) {
                            testPassed = true;
                            errorMessage = `Correctly caught: ${error.message}`;
                        }
                        break;

                    case 'network':
                        try {
                            // Simulate network-dependent operation
                            await appState.setVault(`/network/${trigger}/vault`);
                            errorMessage = 'Expected network error but operation succeeded';
                        } catch (error) {
                            testPassed = true;
                            errorMessage = `Correctly caught: ${error.message}`;
                        }
                        break;

                    case 'resources':
                        try {
                            await appState.setCurrentFile(`/test/${trigger}/file.md`);
                            autoSave.setContentGetter(() => 'Test content');
                            await autoSave.saveNow();
                            errorMessage = 'Expected resource error but operation succeeded';
                        } catch (error) {
                            testPassed = true;
                            errorMessage = `Correctly caught: ${error.message}`;
                        }
                        break;
                }

                // Update UI
                statusElement.textContent = testPassed ? 'PASS' : 'FAIL';
                statusElement.className = `scenario-status ${testPassed ? 'status-pass' : 'status-fail'}`;
                
                detailsElement.textContent = errorMessage;
                detailsElement.style.display = 'block';

                // Record result
                testResults.push({
                    scenario: trigger,
                    category,
                    passed: testPassed,
                    message: errorMessage
                });

                log(`Scenario ${trigger}: ${testPassed ? 'PASS' : 'FAIL'} - ${errorMessage}`, 
                    testPassed ? 'success' : 'error');

            } catch (error) {
                statusElement.textContent = 'ERROR';
                statusElement.className = 'scenario-status status-fail';
                
                detailsElement.textContent = `Test error: ${error.message}`;
                detailsElement.style.display = 'block';

                log(`Scenario ${trigger} test failed: ${error.message}`, 'error');
            }

            updateStats();
        }

        window.testScenario = testScenario;

        window.runAllErrorScenarios = async function() {
            log('Starting comprehensive error scenario testing...', 'info');
            
            for (const [category, scenarios] of Object.entries(errorScenarios)) {
                log(`Testing ${category} error scenarios...`, 'info');
                
                for (const scenario of scenarios) {
                    await testScenario(scenario.trigger, category);
                    // Small delay to prevent overwhelming the UI
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }

            log('All error scenario tests completed!', 'success');
            generateRecoveryStrategies();
        };

        window.runFileSystemErrors = async function() {
            log('Testing file system error scenarios...', 'info');
            for (const scenario of errorScenarios.fileSystem) {
                await testScenario(scenario.trigger, 'fileSystem');
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        };

        window.runPermissionErrors = async function() {
            log('Testing permission error scenarios...', 'info');
            for (const scenario of errorScenarios.permissions) {
                await testScenario(scenario.trigger, 'permissions');
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        };

        window.runCorruptionErrors = async function() {
            log('Testing corruption error scenarios...', 'info');
            for (const scenario of errorScenarios.corruption) {
                await testScenario(scenario.trigger, 'corruption');
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        };

        window.runNetworkErrors = async function() {
            log('Testing network error scenarios...', 'info');
            for (const scenario of errorScenarios.network) {
                await testScenario(scenario.trigger, 'network');
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        };

        window.runResourceErrors = async function() {
            log('Testing resource error scenarios...', 'info');
            for (const scenario of errorScenarios.resources) {
                await testScenario(scenario.trigger, 'resources');
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        };

        window.clearResults = function() {
            testResults = [];
            errorResults.clear();
            updateStats();
            
            // Reset all scenario cards
            Object.values(errorScenarios).flat().forEach(scenario => {
                const statusElement = document.getElementById(`status-${scenario.trigger}`);
                const detailsElement = document.getElementById(`details-${scenario.trigger}`);
                
                if (statusElement) {
                    statusElement.textContent = 'Ready';
                    statusElement.className = 'scenario-status status-ready';
                }
                
                if (detailsElement) {
                    detailsElement.style.display = 'none';
                }
            });

            document.getElementById('errorLog').innerHTML = '';
            document.getElementById('recoveryStrategies').innerHTML = '';
            
            log('Results cleared. Ready for new tests.', 'info');
        };

        function generateRecoveryStrategies() {
            const strategies = document.getElementById('recoveryStrategies');
            const categoryResults = {};
            
            // Group results by category
            testResults.forEach(result => {
                if (!categoryResults[result.category]) {
                    categoryResults[result.category] = [];
                }
                categoryResults[result.category].push(result);
            });

            let strategiesHtml = '';
            Object.entries(categoryResults).forEach(([category, results]) => {
                const passed = results.filter(r => r.passed).length;
                const total = results.length;
                const rate = ((passed / total) * 100).toFixed(1);
                
                strategiesHtml += `
                    <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px; border-left: 4px solid #17a2b8;">
                        <strong>${category.charAt(0).toUpperCase() + category.slice(1)} Errors:</strong> 
                        ${passed}/${total} scenarios handled correctly (${rate}%)
                        <div style="font-size: 12px; margin-top: 5px; color: #6c757d;">
                            ${getRecoveryStrategy(category)}
                        </div>
                    </div>
                `;
            });

            strategies.innerHTML = strategiesHtml;
        }

        function getRecoveryStrategy(category) {
            const strategies = {
                fileSystem: 'Implement retry logic with exponential backoff. Validate paths before operations. Provide clear error messages to users.',
                permissions: 'Check permissions before operations. Request elevation when needed. Implement graceful degradation for read-only scenarios.',
                corruption: 'Implement backup and recovery mechanisms. Validate file integrity. Provide repair options where possible.',
                network: 'Implement offline mode. Cache critical data locally. Retry failed operations with timeout limits.',
                resources: 'Monitor resource usage. Implement cleanup routines. Provide user warnings before limits are reached.'
            };
            return strategies[category] || 'Monitor and handle errors gracefully with user feedback.';
        }

        // Initialize
        renderScenarios();
        updateStats();
        log('Error scenario testing system initialized. Select test categories to begin.', 'success');
    </script>
</body>
</html>